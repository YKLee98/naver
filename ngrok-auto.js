#!/usr/bin/env node

/**
 * ngrok 자동 설정 및 실행 스크립트
 * - ngrok을 자동으로 실행하고 URL을 가져옴
 * - 환경 파일 자동 업데이트
 * - 서버 자동 재시작
 */

const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const axios = require('axios');

// 색상 코드
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m'
};

function log(message, color = 'reset') {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`${colors.cyan}[${timestamp}]${colors.reset} ${colors[color]}${message}${colors.reset}`);
}

class NgrokManager {
  constructor() {
    this.ngrokProcess = null;
    this.ngrokUrl = null;
  }

  async start() {
    log('🚀 Starting ngrok tunnel for port 5173...', 'yellow');
    
    // ngrok 프로세스 시작
    this.ngrokProcess = spawn('ngrok', ['http', '5173'], {
      shell: true,
      detached: false
    });

    // ngrok이 시작될 때까지 대기
    await new Promise(resolve => setTimeout(resolve, 3000));

    // ngrok API에서 URL 가져오기
    try {
      const response = await axios.get('http://127.0.0.1:4040/api/tunnels');
      const tunnels = response.data.tunnels;
      
      if (tunnels && tunnels.length > 0) {
        // https URL 우선
        const httpsTunnel = tunnels.find(t => t.proto === 'https') || tunnels[0];
        this.ngrokUrl = httpsTunnel.public_url;
        log(`✅ ngrok URL: ${this.ngrokUrl}`, 'green');
        return this.ngrokUrl;
      }
    } catch (error) {
      log('⚠️  Could not get ngrok URL automatically', 'yellow');
      log('Please check http://127.0.0.1:4040 for the URL', 'yellow');
    }
    
    return null;
  }

  stop() {
    if (this.ngrokProcess) {
      this.ngrokProcess.kill();
      log('🛑 ngrok tunnel stopped', 'yellow');
    }
  }
}

class EnvUpdater {
  updateFiles(ngrokUrl) {
    const rootEnvPath = path.join(__dirname, '.env');
    const frontendEnvPath = path.join(__dirname, 'packages', 'frontend', '.env');
    const backendEnvPath = path.join(__dirname, 'packages', 'backend', '.env');
    
    try {
      // 1. 루트 .env 업데이트
      let rootEnv = '';
      if (fs.existsSync(rootEnvPath)) {
        rootEnv = fs.readFileSync(rootEnvPath, 'utf8');
      }
      
      // ngrok_url 업데이트 또는 추가
      if (rootEnv.includes('ngrok_url=')) {
        rootEnv = rootEnv.replace(/ngrok_url=.*/g, `ngrok_url=${ngrokUrl}`);
      } else {
        rootEnv += `\nngrok_url=${ngrokUrl}\n`;
      }
      
      // CORS_ORIGIN 업데이트
      if (rootEnv.includes('CORS_ORIGIN=')) {
        rootEnv = rootEnv.replace(/CORS_ORIGIN=.*/g, `CORS_ORIGIN=http://localhost:5173,${ngrokUrl}`);
      } else {
        rootEnv += `CORS_ORIGIN=http://localhost:5173,${ngrokUrl}\n`;
      }
      
      fs.writeFileSync(rootEnvPath, rootEnv);
      log('✅ Updated root .env', 'green');
      
      // 2. 프론트엔드 .env 생성/업데이트
      const frontendEnv = `# Auto-generated by ngrok-auto.js
# ngrok URL for mobile access
VITE_NGROK_URL=${ngrokUrl}

# API URL - uses proxy in development
VITE_API_URL=/api/v1

# Backend URL for direct access (if needed)
VITE_BACKEND_URL=http://localhost:3000
`;
      
      fs.writeFileSync(frontendEnvPath, frontendEnv);
      log('✅ Updated frontend .env', 'green');
      
      // 3. 백엔드 .env 생성/업데이트 (필요한 경우)
      if (!fs.existsSync(backendEnvPath)) {
        // 백엔드 .env가 없으면 루트에서 복사
        if (fs.existsSync(rootEnvPath)) {
          fs.copyFileSync(rootEnvPath, backendEnvPath);
          log('✅ Created backend .env from root', 'green');
        }
      }
      
      return true;
    } catch (error) {
      log(`❌ Error updating env files: ${error.message}`, 'red');
      return false;
    }
  }
}

class ServerManager {
  constructor() {
    this.processes = [];
  }

  async startServers() {
    log('🚀 Starting development servers...', 'yellow');
    
    // 백엔드 서버 시작
    const backendProcess = spawn('pnpm', ['dev'], {
      cwd: path.join(__dirname, 'packages', 'backend'),
      shell: true,
      stdio: 'inherit'
    });
    this.processes.push(backendProcess);
    log('✅ Backend server started', 'green');
    
    // 프론트엔드 서버 시작
    const frontendProcess = spawn('pnpm', ['dev'], {
      cwd: path.join(__dirname, 'packages', 'frontend'),
      shell: true,
      stdio: 'inherit'
    });
    this.processes.push(frontendProcess);
    log('✅ Frontend server started', 'green');
    
    return true;
  }

  stopAll() {
    this.processes.forEach(p => {
      if (p && !p.killed) {
        p.kill();
      }
    });
    log('🛑 All servers stopped', 'yellow');
  }
}

async function main() {
  console.clear();
  log('=' .repeat(60), 'magenta');
  log('🚀 ngrok Auto Setup & Runner', 'bright');
  log('=' .repeat(60), 'magenta');
  log('');
  
  const ngrokManager = new NgrokManager();
  const envUpdater = new EnvUpdater();
  const serverManager = new ServerManager();
  
  try {
    // 1. ngrok 시작 및 URL 가져오기
    const ngrokUrl = await ngrokManager.start();
    
    if (!ngrokUrl) {
      log('❌ Failed to get ngrok URL', 'red');
      log('Please start ngrok manually: ngrok http 5173', 'yellow');
      process.exit(1);
    }
    
    // 2. 환경 파일 업데이트
    if (!envUpdater.updateFiles(ngrokUrl)) {
      process.exit(1);
    }
    
    // 3. 서버 시작
    await serverManager.startServers();
    
    // 4. 성공 메시지 출력
    log('', 'reset');
    log('=' .repeat(60), 'green');
    log('✨ Setup Complete!', 'bright');
    log('=' .repeat(60), 'green');
    log('', 'reset');
    log('📱 Access URLs:', 'yellow');
    log(`   Local:  http://localhost:5173`, 'blue');
    log(`   Mobile: ${ngrokUrl}`, 'bright');
    log('', 'reset');
    log('📋 Dashboard: ' + ngrokUrl + '/dashboard', 'cyan');
    log('📦 Inventory: ' + ngrokUrl + '/inventory', 'cyan');
    log('🔗 SKU Mapping: ' + ngrokUrl + '/sku-mapping', 'cyan');
    log('', 'reset');
    log('Press Ctrl+C to stop all services', 'yellow');
    log('', 'reset');
    
  } catch (error) {
    log(`❌ Error: ${error.message}`, 'red');
    process.exit(1);
  }
  
  // 종료 처리
  process.on('SIGINT', () => {
    log('\n\n🛑 Shutting down...', 'yellow');
    ngrokManager.stop();
    serverManager.stopAll();
    log('👋 Goodbye!', 'cyan');
    process.exit(0);
  });
}

// package.json에 스크립트 추가 확인
function addScriptsToPackageJson() {
  const packageJsonPath = path.join(__dirname, 'package.json');
  
  try {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    if (!packageJson.scripts) {
      packageJson.scripts = {};
    }
    
    // 스크립트 추가
    packageJson.scripts['ngrok'] = 'node ngrok-auto.js';
    packageJson.scripts['ngrok:setup'] = 'node setup-ngrok.js';
    
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    log('✅ Added npm scripts to package.json', 'green');
  } catch (error) {
    log('⚠️  Could not update package.json scripts', 'yellow');
  }
}

// 의존성 확인
function checkDependencies() {
  try {
    require('axios');
  } catch (e) {
    log('Installing required dependencies...', 'yellow');
    require('child_process').execSync('npm install axios', { stdio: 'inherit' });
  }
}

// 실행
checkDependencies();
addScriptsToPackageJson();
main();
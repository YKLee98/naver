#!/usr/bin/env node

/**
 * ngrok ìë™ ì„¤ì • ë° ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
 * - ngrokì„ ìë™ìœ¼ë¡œ ì‹¤í–‰í•˜ê³  URLì„ ê°€ì ¸ì˜´
 * - í™˜ê²½ íŒŒì¼ ìë™ ì—…ë°ì´íŠ¸
 * - ì„œë²„ ìë™ ì¬ì‹œì‘
 */

const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const axios = require('axios');

// ìƒ‰ìƒ ì½”ë“œ
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m'
};

function log(message, color = 'reset') {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`${colors.cyan}[${timestamp}]${colors.reset} ${colors[color]}${message}${colors.reset}`);
}

class NgrokManager {
  constructor() {
    this.ngrokProcess = null;
    this.ngrokUrl = null;
  }

  async start() {
    log('ğŸš€ Starting ngrok tunnel for port 5173...', 'yellow');
    
    // ngrok í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    this.ngrokProcess = spawn('ngrok', ['http', '5173'], {
      shell: true,
      detached: false
    });

    // ngrokì´ ì‹œì‘ë  ë•Œê¹Œì§€ ëŒ€ê¸°
    await new Promise(resolve => setTimeout(resolve, 3000));

    // ngrok APIì—ì„œ URL ê°€ì ¸ì˜¤ê¸°
    try {
      const response = await axios.get('http://127.0.0.1:4040/api/tunnels');
      const tunnels = response.data.tunnels;
      
      if (tunnels && tunnels.length > 0) {
        // https URL ìš°ì„ 
        const httpsTunnel = tunnels.find(t => t.proto === 'https') || tunnels[0];
        this.ngrokUrl = httpsTunnel.public_url;
        log(`âœ… ngrok URL: ${this.ngrokUrl}`, 'green');
        return this.ngrokUrl;
      }
    } catch (error) {
      log('âš ï¸  Could not get ngrok URL automatically', 'yellow');
      log('Please check http://127.0.0.1:4040 for the URL', 'yellow');
    }
    
    return null;
  }

  stop() {
    if (this.ngrokProcess) {
      this.ngrokProcess.kill();
      log('ğŸ›‘ ngrok tunnel stopped', 'yellow');
    }
  }
}

class EnvUpdater {
  updateFiles(ngrokUrl) {
    const rootEnvPath = path.join(__dirname, '.env');
    const frontendEnvPath = path.join(__dirname, 'packages', 'frontend', '.env');
    const backendEnvPath = path.join(__dirname, 'packages', 'backend', '.env');
    
    try {
      // 1. ë£¨íŠ¸ .env ì—…ë°ì´íŠ¸
      let rootEnv = '';
      if (fs.existsSync(rootEnvPath)) {
        rootEnv = fs.readFileSync(rootEnvPath, 'utf8');
      }
      
      // ngrok_url ì—…ë°ì´íŠ¸ ë˜ëŠ” ì¶”ê°€
      if (rootEnv.includes('ngrok_url=')) {
        rootEnv = rootEnv.replace(/ngrok_url=.*/g, `ngrok_url=${ngrokUrl}`);
      } else {
        rootEnv += `\nngrok_url=${ngrokUrl}\n`;
      }
      
      // CORS_ORIGIN ì—…ë°ì´íŠ¸
      if (rootEnv.includes('CORS_ORIGIN=')) {
        rootEnv = rootEnv.replace(/CORS_ORIGIN=.*/g, `CORS_ORIGIN=http://localhost:5173,${ngrokUrl}`);
      } else {
        rootEnv += `CORS_ORIGIN=http://localhost:5173,${ngrokUrl}\n`;
      }
      
      fs.writeFileSync(rootEnvPath, rootEnv);
      log('âœ… Updated root .env', 'green');
      
      // 2. í”„ë¡ íŠ¸ì—”ë“œ .env ìƒì„±/ì—…ë°ì´íŠ¸
      const frontendEnv = `# Auto-generated by ngrok-auto.js
# ngrok URL for mobile access
VITE_NGROK_URL=${ngrokUrl}

# API URL - uses proxy in development
VITE_API_URL=/api/v1

# Backend URL for direct access (if needed)
VITE_BACKEND_URL=http://localhost:3000
`;
      
      fs.writeFileSync(frontendEnvPath, frontendEnv);
      log('âœ… Updated frontend .env', 'green');
      
      // 3. ë°±ì—”ë“œ .env ìƒì„±/ì—…ë°ì´íŠ¸ (í•„ìš”í•œ ê²½ìš°)
      if (!fs.existsSync(backendEnvPath)) {
        // ë°±ì—”ë“œ .envê°€ ì—†ìœ¼ë©´ ë£¨íŠ¸ì—ì„œ ë³µì‚¬
        if (fs.existsSync(rootEnvPath)) {
          fs.copyFileSync(rootEnvPath, backendEnvPath);
          log('âœ… Created backend .env from root', 'green');
        }
      }
      
      return true;
    } catch (error) {
      log(`âŒ Error updating env files: ${error.message}`, 'red');
      return false;
    }
  }
}

class ServerManager {
  constructor() {
    this.processes = [];
  }

  async startServers() {
    log('ğŸš€ Starting development servers...', 'yellow');
    
    // ë°±ì—”ë“œ ì„œë²„ ì‹œì‘
    const backendProcess = spawn('pnpm', ['dev'], {
      cwd: path.join(__dirname, 'packages', 'backend'),
      shell: true,
      stdio: 'inherit'
    });
    this.processes.push(backendProcess);
    log('âœ… Backend server started', 'green');
    
    // í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì‹œì‘
    const frontendProcess = spawn('pnpm', ['dev'], {
      cwd: path.join(__dirname, 'packages', 'frontend'),
      shell: true,
      stdio: 'inherit'
    });
    this.processes.push(frontendProcess);
    log('âœ… Frontend server started', 'green');
    
    return true;
  }

  stopAll() {
    this.processes.forEach(p => {
      if (p && !p.killed) {
        p.kill();
      }
    });
    log('ğŸ›‘ All servers stopped', 'yellow');
  }
}

async function main() {
  console.clear();
  log('=' .repeat(60), 'magenta');
  log('ğŸš€ ngrok Auto Setup & Runner', 'bright');
  log('=' .repeat(60), 'magenta');
  log('');
  
  const ngrokManager = new NgrokManager();
  const envUpdater = new EnvUpdater();
  const serverManager = new ServerManager();
  
  try {
    // 1. ngrok ì‹œì‘ ë° URL ê°€ì ¸ì˜¤ê¸°
    const ngrokUrl = await ngrokManager.start();
    
    if (!ngrokUrl) {
      log('âŒ Failed to get ngrok URL', 'red');
      log('Please start ngrok manually: ngrok http 5173', 'yellow');
      process.exit(1);
    }
    
    // 2. í™˜ê²½ íŒŒì¼ ì—…ë°ì´íŠ¸
    if (!envUpdater.updateFiles(ngrokUrl)) {
      process.exit(1);
    }
    
    // 3. ì„œë²„ ì‹œì‘
    await serverManager.startServers();
    
    // 4. ì„±ê³µ ë©”ì‹œì§€ ì¶œë ¥
    log('', 'reset');
    log('=' .repeat(60), 'green');
    log('âœ¨ Setup Complete!', 'bright');
    log('=' .repeat(60), 'green');
    log('', 'reset');
    log('ğŸ“± Access URLs:', 'yellow');
    log(`   Local:  http://localhost:5173`, 'blue');
    log(`   Mobile: ${ngrokUrl}`, 'bright');
    log('', 'reset');
    log('ğŸ“‹ Dashboard: ' + ngrokUrl + '/dashboard', 'cyan');
    log('ğŸ“¦ Inventory: ' + ngrokUrl + '/inventory', 'cyan');
    log('ğŸ”— SKU Mapping: ' + ngrokUrl + '/sku-mapping', 'cyan');
    log('', 'reset');
    log('Press Ctrl+C to stop all services', 'yellow');
    log('', 'reset');
    
  } catch (error) {
    log(`âŒ Error: ${error.message}`, 'red');
    process.exit(1);
  }
  
  // ì¢…ë£Œ ì²˜ë¦¬
  process.on('SIGINT', () => {
    log('\n\nğŸ›‘ Shutting down...', 'yellow');
    ngrokManager.stop();
    serverManager.stopAll();
    log('ğŸ‘‹ Goodbye!', 'cyan');
    process.exit(0);
  });
}

// package.jsonì— ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€ í™•ì¸
function addScriptsToPackageJson() {
  const packageJsonPath = path.join(__dirname, 'package.json');
  
  try {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    if (!packageJson.scripts) {
      packageJson.scripts = {};
    }
    
    // ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€
    packageJson.scripts['ngrok'] = 'node ngrok-auto.js';
    packageJson.scripts['ngrok:setup'] = 'node setup-ngrok.js';
    
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    log('âœ… Added npm scripts to package.json', 'green');
  } catch (error) {
    log('âš ï¸  Could not update package.json scripts', 'yellow');
  }
}

// ì˜ì¡´ì„± í™•ì¸
function checkDependencies() {
  try {
    require('axios');
  } catch (e) {
    log('Installing required dependencies...', 'yellow');
    require('child_process').execSync('npm install axios', { stdio: 'inherit' });
  }
}

// ì‹¤í–‰
checkDependencies();
addScriptsToPackageJson();
main();